# Methods of Primitives

JavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such.

One of the best things about objects is that we can store a function as one of its properties.
```js
let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
```

## A primitive as an object
Here’s the paradox faced by the creator of JavaScript:

There are many things one would want to do with a primitive like a string or a number. It would be great to access them using methods.
- Primitives must be as fast and lightweight as possible.
- The solution looks a little bit awkward, but here it is:

Primitives are still primitive. A single value, as desired.
- The language allows access to methods and properties of strings, numbers, booleans and symbols.
- In order for that to work, a special “object wrapper” that provides the extra functionality is created, and then is destroyed.
- The “object wrappers” are different for each primitive type and are called: String, Number, Boolean and Symbol. Thus, they provide different sets of methods.

For instance, there exists a string method str.toUpperCase() that returns a capitalized str.

Here’s how it works:
```js
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
```
Here’s what actually happens in str.toUpperCase():

1. The string str is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().
2. That method runs and returns a new string (shown by alert).
3. The special object is destroyed, leaving the primitive str alone.

# Numbers

In modern JavaScript, there are two types of numbers:

1. Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”.
2. BigInt numbers, to represent integers of arbitrary length. They are sometimes needed, because a regular number can’t safely exceed 253 or be less than -253.

## Writing Numbers
```js
let billion = 1_000_000_000;
```
Acceptable ```_``` are ignored.

In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:
```js
let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes
let ms = 0.000001;
let ms = 1e-6; // six zeroes to the left from 1
```

Hexadecimal, octal and Binary Numbers
```js
alert( 0xff ); // 255 Hexadecimal
alert( 0b111111) //binary
alert( 0o377 ) //octal
```
There are only 3 numeral systems with such support. For other numeral systems, we should use the function parseInt.

### toString(base)
The method num.toString(base) returns a string representation of num in the numeral system with the given base.

For example:
```js
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```
The base can vary from 2 to 36. By default it’s 10.
When directly using on a number we need to use two dots.

### Rounding
There are several built-in functions for rounding:

``Math.floor``
Rounds down: 3.1 becomes 3, and -1.1 becomes -2.
``Math.ceil``
Rounds up: 3.1 becomes 4, and -1.1 becomes -1.
``Math.round``
Rounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4, the middle case: 3.5 rounds up to 4 too.
``Math.trunc`` (not supported by Internet Explorer)
Removes anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.

The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.
```js
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
```

We should always use ```.toFixed``` method while dealing with floating point numbers as there tends be a precision error.

## parseInt and parseFloat
Numeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails:
```js
alert( +"100px" ); // NaN
```
So in such cases we have methods like ```parseInt()``` and ```parseFloat()```. They “read” a number from a string until they can’t. In case of an error, the gathered number is returned. The second argument of ```parseInt(str, radix)``` The function parseInt returns an integer, whilst parseFloat will return a floating-point number:
```js
alert( parseInt("100px") ); //100
alert( parseInt('a123') ); // NaN, the first symbol stops the process
```

# Strings 
In JavaScript, the textual data is stored as strings. There is no separate type for a single character.

Advantage of using backticks is that they allow a string to span multiple lines:
```js
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // a list of guests, multiple lines
```
It is still possible to create multiline strings with single and double quotes by using a so-called “newline character”, written as \n, which denotes a line break:
```js
let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // a multiline list of guests
```

Length is a property of and not a method 
```js
const str='Tushar'
console.log(str.length);
console.log(str.length()); // would not work
```

We can acess characters in string like 
```js
const str='Tushar'
console.log(str[0]); //T
console.log(str.charAt(0)); // T
```
The only difference between them is that if no character is found, [] returns undefined, and charAt returns an empty string.

Strings are immutable. The workaround is to create a new string and assign the new value there.
```js 
let str = 'Hi';

str = 'h' + str[1]; // replace the string

alert( str ); // hi
```
## Searching for a substring
**str.indexOf**
The first method is str.indexOf(substr, pos).

It looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found.
```js
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning
alert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive

alert( str.indexOf("id") ); // 1, "id" is found at the position 1 (..idget with id)
```
It returns the first positon at which the word appears.

Also we have something like ```str.lastIndexOf(substr, position)```

## The bitwise NOT trick
One of the old tricks used here is the bitwise NOT ~ operator. It converts the number to a 32-bit integer (removes the decimal part if exists) and then reverses all bits in its binary representation.

In practice, that means a simple thing: for 32-bit integers ~n equals -(n+1).

For instance:
```js
alert( ~2 ); // -3, the same as -(2+1)
alert( ~1 ); // -2, the same as -(1+1)
alert( ~0 ); // -1, the same as -(0+1)
alert( ~-1 ); // 0, the same as -(-1+1)
```

We have other methods such as includes, startsWith, endsWith.

## Getting a substring
There are 3 methods in JavaScript to get a substring: substring, substr and slice.
```str.slice(start [, end])```
Returns the part of the string from start to (but not including) end.
Negative values for start/end are also possible. They mean the position is counted from the string end:
```js
let str = "stringify";

// start at the 4th position from the right, end at the 1st from the right
alert( str.slice(-4, -1) ); // 'gif'
```

```str.substring(start [, end])```
Returns the part of the string between start and end.

```str.substr(start [, length])```
Returns the part of the string from start, with the given length.

## Comparing Strings
strings are compared character-by-character in alphabetical order.

Although, there are some oddities.

A lowercase letter is always greater than the uppercase:

```alert( 'a' > 'Z' ); // true```

Letters with diacritical marks are “out of order”:
```alert( 'Österreich' > 'Zealand' ); // true```

All strings are encoded using UTF-16. That is: each character has a corresponding numeric code. There are special methods that allow to get the character for the code and back.

```str.codePointAt(pos)```
Returns the code for the character at position pos:
```js
// different case letters have different codes
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
String.fromCodePoint(code)
```

Creates a character by its numeric code
```js
alert( String.fromCodePoint(90) ); // Z
We can also add Unicode characters by their codes using \u followed by the hex code:

// 90 is 5a in hexadecimal system
alert( '\u005a' ); // Z
```
The characters are compared by their numeric code. The greater code means that the character is greater. The code for a (97) is greater than the code for Z (90).

## Correct comparisons
The call str.localeCompare(str2) returns an integer indicating whether str is less, equal or greater than str2 according to the language rules:

Returns a negative number if str is less than str2.
Returns a positive number if str is greater than str2.
Returns 0 if they are equivalent.

```js
str.localeCompare(str2)
```

# Arrays
There are two syntaxes for creating an empty array:
```js
let arr = new Array();
let arr = [];
```
## Methods pop/push, shift/unshift
A queue is one of the most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations:

*push* appends an element to the end.
*shift* get an element from the beginning, advancing the queue, so that the 2nd element becomes the 1st.

There’s another use case for arrays – the data structure named ```stack```.

It supports two operations:
*push* adds an element to the end.
*pop* takes an element from the end.
So new elements are added or taken always from the “end”.

push, pop work at the end by inserting and removing elements from back while shift and unshift work at beginning of array by removing and inserting element respectively.

## Internals
An array is a special kind of object. The square brackets used to access a property arr[0] actually come from the object syntax. That’s essentially the same as obj[key], where arr is the object, while numbers are used as keys.
Because arrays are objects at their base. We can add any properties to them.

But the engine will see that we’re working with the array as with a regular object. Array-specific optimizations are not suited for such cases and will be turned off, their benefits disappear.

## Performance
Methods push/pop run fast, while shift/unshift are slow.

## Looping 

### ```for..of```
```js
let fruits = ["Apple", "Orange", "Plum"];

// iterates over array elements
for (let fruit of fruits) {
  alert( fruit );
}
```
The ```for..of``` doesn’t give access to the number of the current element, just its value, but in most cases that’s enough. And it’s shorter.

### ```for..in```
Technically, because arrays are objects, it is also possible to use for..in:
```js
let arr = ["Apple", "Orange", "Pear"];

for (let key in arr) {
  alert( arr[key] ); // Apple, Orange, Pear
}
```
But that’s actually a bad idea. There are potential problems with it:

The loop for..in iterates over all properties, not only the numeric ones.
The ```for..in``` loop is optimized for generic objects

### Length
The length property automatically updates when we modify the array. To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one.

For instance, a single element with a large index gives a big length:
```js
let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); // 124
```

## toString
Arrays have their own implementation of toString method that returns a comma-separated list of elements.

For instance:
```js
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```
Also, let’s try this:
```js
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```
Arrays do not have ```Symbol.toPrimitive```, neither a viable valueOf, they implement only toString conversion, so here [] becomes an empty string, [1] becomes "1" and [1,2] becomes "1,2".

When the binary plus "+" operator adds something to a string, it converts it to a string as well, so the next step looks like this:
```js
alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
```
Arrays in JavaScript, unlike some other programming languages, shouldn’t be compared with operator ==.

This operator has no special treatment for arrays, it works with them as with any objects.

Let’s recall the rules:

- Two objects are equal == only if they’re references to the same object.
- If one of the arguments of == is an object, and the other one is a primitive, then the object gets converted to primitive, as explained in the chapter Object to primitive conversion.
…With an exception of null and undefined that equal == each other and nothing else.

# Array Methods
## Add/remove items
arr.push(...items) – adds items to the end,
arr.pop() – extracts an item from the end,
arr.shift() – extracts an item from the beginning,
arr.unshift(...items) – adds items to the beginning.

## Splice 
As array is an object we can use ```delete``` but it won't change the length property of the array.
So we use splice instead. It can do everything: insert, remove and replace elements.

The syntax is:
```js
arr.splice(start[, deleteCount, elem1, ..., elemN])
```
It modifies ``arr`` starting from the index ``start``: removes ``deleteCount`` elements and then inserts ``elem1, ..., elemN`` at their place. Returns the array of removed elements.
```js
let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 2 first elements
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- array of removed elements
```
The splice method is also able to insert the elements without any removals. For that we need to set deleteCount to 0:
```js
let arr = ["I", "study", "JavaScript"];

// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```

### Negative indexes allowed
Here and in other array methods, negative indexes are allowed. They specify the position from the end of the array, like here:
```js
let arr = [1, 2, 5];

// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```

## slice
The method arr.slice is much simpler than similar-looking arr.splice.

The syntax is:
```js
arr.slice([start], [end])
```
It returns a new array copying to it all items from index start to end (not including end). Both start and end can be negative, in that case position from array end is assumed.

## concat
The method arr.concat creates a new array that includes values from other arrays and additional items.

The syntax is:
```js
arr.concat(arg1, arg2...)
```
It accepts any number of arguments – either arrays or values.
The result is a new array containing items from arr, then arg1, arg2 etc.

- If an array-like object has a special Symbol.isConcatSpreadable property, then it’s treated as an array by concat: its elements are added instead:
```js
let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```
## Iterate: forEach
The arr.forEach method allows to run a function for every element of the array.

The syntax:
```js
arr.forEach(function(item, index, array) {
  // ... do something with item
});

[1,2,4,5].forEach((item,index,array) => {
console.log(item, index, array);
})
```

## Searching in array
**indexOf/lastIndexOf and includes**
The methods ``arr.indexOf``, ``arr.lastIndexOf`` and ``arr.includes`` have the same syntax and do essentially the same as their string counterparts, but operate on items instead of characters:
```
arr.indexOf(item, from) – looks for item starting from index from, and returns the index where it was found, otherwise -1.
arr.lastIndexOf(item, from) – same, but looks for from right to left.
arr.includes(item, from) – looks for item starting from index from, returns true if found.
```
For instance:
```js
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```

**find and findIndex**
If we have to find objects with certain properties we need to use ``find`` because we cannot use for loops for them as they will result in ``[object][obejct]``.
The function is called for elements of the array, one after another:

``item`` is the element.
``index`` is its index.
``array`` is the array itself.
For example, we have an array of users, each with the fields id and name.
```js
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```
**filter**
The ``find`` method looks for a single (first) element that makes the function return true.

If there may be many, we can use arr.filter(fn).
The syntax is similar to find, but filter returns an array of all matching elements.

For instance:
```js
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// returns array of the first two users
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

## Transform an array
**map**
It calls the function for each element of the array and returns the array of results.
```js
let modifiedArray = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.toUpperCase());
alert(lengths); // 5,7,6

```

**sort(fn)**
The call to arr.sort() sorts the array in place, changing its element order.

It also returns the sorted array, but the returned value is usually ignored, as ``arr`` itself is modified.
__The items are sorted as strings by default__.

Literally, all elements are converted to strings for comparisons. For strings, lexicographic ordering is applied and indeed "2" > "15".
```js
let arr = [ 1, 2, 15 ];

// the method reorders the content of arr
arr.sort();

alert( arr );  // 1, 15, 2
```

To use our own sorting order, we need to supply a function as the argument of arr.sort(). The deault is string comparison order. 
```js
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
```

Actually, a comparison function is only required to return a positive number to say “greater” and a negative number to say “less”.
That allows to write shorter functions:
```js
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
```

**reverse**
It reverses the array elements. 
```js
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

**split and join**
We have a comma separated list how do we convert it into array ?
The ``str.split(delim)`` method does exactly that. It splits the string into an array by the given delimiter ``delim``.

```js
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)
}
```

The split method has an optional second numeric argument – a limit on the array length. If it is provided, then the extra elements are ignored. In practice it is rarely used though:
```js
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```

The call ``arr.join(glue)`` does the reverse to split. It creates a string of arr items joined by glue between them.

For instance:
```js
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // glue the array into a string using ;

alert( str ); // Bilbo;Gandalf;Nazgul
```

**reduce/reduceRight**
When we need to iterate over an array – we can use forEach, ``for`` or ``for..of``.
When we need to iterate and return the data for each element – we can use map. They are used to calculate a single value based on the array.
```js
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```
The function is applied to all array elements one after another and “carries on” its result to the next call.

Arguments:
```js
accumulator – is the result of the previous function call, equals initial the first time (if initial is provided).
item – is the current array item.
index – is its position.
array – is the array.
```
As function is applied, the result of the previous function call is passed to the next one as the first argument.

So, the first argument is essentially the accumulator that stores the combined result of all previous executions. And at the end it becomes the result of reduce.
```js
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

**isArray**
``Array.isArray()`` returns true if its an array.

## Most methods support “thisArg”
```js 
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg is the optional last argument
```
The value of ``thisArg`` parameter becomes this for func.

For example, here we use a method of army object as a filter, and thisArg passes the context:
```js
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// find users, for who army.canJoin returns true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

A call to ```users.filter(army.canJoin, army)``` can be replaced with ```users.filter(user => army.canJoin(user))```, that does the same. The latter is used more often, as it’s a bit easier to understand for most people.

# Iterables
Iterable objects are a generalization of arrays. That’s a concept that allows us to make any object useable in a ``for..of`` loop.

To make a object iterable (and thus let ``for..of`` work) we need to add a method to the object named ``Symbol.iterator`` (a special built-in symbol just for that).
```js
let range = {
  from: 1,
  to: 5
};

// 1. call to for..of initially calls this
range[Symbol.iterator] = function() {

  // ...it returns the iterator object:
  // 2. Onward, for..of works only with this iterator, asking it for next values
  return {
    current: this.from,
    last: this.to,

    // 3. next() is called on each iteration by the for..of loop
    next() {
      // 4. it should return the value as an object {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// now it works!
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

## Calling an iterator explicitly
We’ll iterate over a string in exactly the same way as for..of, but with direct calls. This code creates a string iterator and gets values from it “manually”:
```js
let str = "Hello";

// does the same as
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // outputs characters one by one
}
```

## Iterables and array-likes
Two official terms look similar, but are very different.

Iterables are objects that implement the ``Symbol.iterator`` method, as described above.
Array-likes are objects that have indexes and length, so they look like arrays.
```js
let arrayLike = { // has indexes and length => array-like
  0: "Hello",
  1: "World",
  length: 2
};
```
## Array.from
There’s a universal method Array.from that takes an iterable or array-like value and makes a “real” Array from it. Then we can call array methods on it.

For instance:
```js
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (method works)
```

The full syntax for`` Array.from`` also allows us to provide an optional “mapping” function:
``Array.from(obj[, mapFn, thisArg])``

The optional second argument mapFn can be a function that will be applied to each element before adding it to the array, and thisArg allows us to set this for it.

For instance:
```js
// assuming that range is taken from the example above
// square each number
let arr = Array.from(range, num => num * num);
alert(arr); // 1,4,9,16,25
```

# Maps
- Objects are used for storing keyed collections.
- Arrays are used for storing ordered collections.

Map is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type.

Methods and properties are:
``
new Map() – creates the map.
map.set(key, value) – stores the value by the key.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the value by the key.
map.clear() – removes everything from the map.
map.size – returns the current element count.
``
We should always use the map methods instead of using the plain object methods such as   
``map[key]= '' ❌``

We can use objects as keys in map which is not possible in an object. 
```js
let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // try to use an object

visitsCountObj[ben] = 234; // try to use ben object as the key
visitsCountObj[john] = 123; // try to use john object as the key, ben object will get replaced

// That's what got written!
alert( visitsCountObj["[object Object]"] ); // 123
```
As visitsCountObj is an object, it converts all Object keys, such as john and ben above, to same string "[object Object]".

## Iteration over Map
``
map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.
``

For instance:
```js
let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// iterate over keys (vegetables)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// iterate over values (amounts)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// iterate over [key, value] entries
for (let entry of recipeMap) { // the same as of recipeMap.entries()
  alert(entry); // cucumber,500 (and so on)
}
```
Map also supports ``forEach`` method.

## Object.entries: Map from Object
When a Map is created, we can pass an array (or another iterable) with key/value pairs for initialization, like this:
```js
// array of [key, value] pairs
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
```

If we have a plain object, and we’d like to create a Map from it, then we can use built-in method Object.entries(obj) that returns an array of key/value pairs for an object exactly in that format.

So we can create a map from an object like this:
```js
let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
```
Object.entries returns the array of key/value pairs: [ ["name","John"], ["age", 30] ]. That’s what Map needs.

## Object.fromEntries: Object from Map
There’s Object.fromEntries method that does the reverse: given an array of [key, value] pairs, it creates an object from them:
```js
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
```

We can use Object.fromEntries to get a plain object from Map.

E.g. we store the data in a Map, but we need to pass it to a 3rd-party code that expects a plain object.

Here we go:
```js
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object (*)

// done!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```
A call to map.entries() returns an iterable of key/value pairs, exactly in the right format for Object.fromEntries.

# Set
A Set is a special type collection – “set of values” (without keys), where each value may occur only once.

Its main methods are:
``
new Set(iterable) – creates the set, and if an iterable object is provided (usually an array), copies values from it into the set.
set.add(value) – adds a value, returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.
``
The main feature is that repeated calls of set.add(value) with the same value don’t do anything. That’s the reason why each value appears in a Set only once.
```js
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// visits, some users come multiple times
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set keeps only unique values
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // John (then Pete and Mary)
}
```
## Iteration over Set
We can loop over a set either with for..of or using forEach:
```js
let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// the same with forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```
The same methods Map has for iterators are also supported:
```js
set.keys() – returns an iterable object for values,
set.values() – same as set.keys(), for compatibility with Map,
set.entries() – returns an iterable object for entries [value, value], exists for compatibility with Map.
```