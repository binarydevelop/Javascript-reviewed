# Methods of Primitives

JavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such.

One of the best things about objects is that we can store a function as one of its properties.
```js
let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
```

## A primitive as an object
Here’s the paradox faced by the creator of JavaScript:

There are many things one would want to do with a primitive like a string or a number. It would be great to access them using methods.
- Primitives must be as fast and lightweight as possible.
- The solution looks a little bit awkward, but here it is:

Primitives are still primitive. A single value, as desired.
- The language allows access to methods and properties of strings, numbers, booleans and symbols.
- In order for that to work, a special “object wrapper” that provides the extra functionality is created, and then is destroyed.
- The “object wrappers” are different for each primitive type and are called: String, Number, Boolean and Symbol. Thus, they provide different sets of methods.

For instance, there exists a string method str.toUpperCase() that returns a capitalized str.

Here’s how it works:
```js
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
```
Here’s what actually happens in str.toUpperCase():

1. The string str is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().
2. That method runs and returns a new string (shown by alert).
3. The special object is destroyed, leaving the primitive str alone.

# Numbers

In modern JavaScript, there are two types of numbers:

1. Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”.
2. BigInt numbers, to represent integers of arbitrary length. They are sometimes needed, because a regular number can’t safely exceed 253 or be less than -253.

## Writing Numbers
```js
let billion = 1_000_000_000;
```
Acceptable ```_``` are ignored.

In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:
```js
let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes
let ms = 0.000001;
let ms = 1e-6; // six zeroes to the left from 1
```

Hexadecimal, octal and Binary Numbers
```js
alert( 0xff ); // 255 Hexadecimal
alert( 0b111111) //binary
alert( 0o377 ) //octal
```
There are only 3 numeral systems with such support. For other numeral systems, we should use the function parseInt.

### toString(base)
The method num.toString(base) returns a string representation of num in the numeral system with the given base.

For example:
```js
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```
The base can vary from 2 to 36. By default it’s 10.
When directly using on a number we need to use two dots.

### Rounding
There are several built-in functions for rounding:

``Math.floor``
Rounds down: 3.1 becomes 3, and -1.1 becomes -2.
``Math.ceil``
Rounds up: 3.1 becomes 4, and -1.1 becomes -1.
``Math.round``
Rounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4, the middle case: 3.5 rounds up to 4 too.
``Math.trunc`` (not supported by Internet Explorer)
Removes anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.

The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.
```js
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
```

We should always use ```.toFixed``` method while dealing with floating point numbers as there tends be a precision error.

## parseInt and parseFloat
Numeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails:
```js
alert( +"100px" ); // NaN
```
So in such cases we have methods like ```parseInt()``` and ```parseFloat()```. They “read” a number from a string until they can’t. In case of an error, the gathered number is returned. The second argument of ```parseInt(str, radix)``` The function parseInt returns an integer, whilst parseFloat will return a floating-point number:
```js
alert( parseInt("100px") ); //100
alert( parseInt('a123') ); // NaN, the first symbol stops the process
```