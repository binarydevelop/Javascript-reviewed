## Object Methods, "this" 

**A function that is a property of an object is called its method**.
```js
let a = {
   c:  function a1() {
        console.log('HI');
    }
}
// below is also valid 
let a = {
   c: () =>  {
        console.log('HI');
    }
}
```
Method shorthand
There exists a shorter syntax for methods in an object literal:
```js
// these objects do the same

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// method shorthand looks better, right?
user = {
  name: "Tushar",
  sayHi() { // same as "sayHi: function(){...}"
    alert(this.name);
    alert(user.name); //this will give the same result 
  }
};
```
As demonstrated, we can omit "function" and just write ``sayHi()``. To access the object, a method can use the **this** keyword.

In JavaScript, keyword  **this** behaves unlike most other programming languages. It can be used in any function, even if it’s not a method of an`` object..`` **this** keyword will take place of object passed 
Example: 
```js
let user = {name: "Tushar"};
let admin = {};
function objectName() {
  console.log(this.name);
}

user.whatName = objectName; // this takes the valie of the object before the dot notation this = user
admin.whatName = objectName; // this = admin

user.whatName(); // Tushar
admin.whatName(); // undefined cause this refers to admin object and it has undefined property name 

```

### Arrow functions have no “this”
If we reference ```this``` from such a function, it’s taken from the outer “normal” function.
``this`` holds the value of current object if the function is inside an object being a method. 

For instance, here arrow() uses this from the outer ``user.sayHi()`` method:
```js
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```
 We can return references to the object by returning ```this``` it makes functions chainable.

 If a method is called with an object before the dot it has ``this`` property else its ``undefiend``
```js
 function makeUser() {
  return {
    name: 'tushar',
    ref: this
  }
}


let user = makeUser(); 
alert( user.ref.name ); // undefined because it is called as a function in above line without an object. 
```
```js
// so the solution is to make ref as a method and it will be able to access the this property. 
function makeUser() {
  return {
    name: 'tushar',
    ref() {
      return this
    }
  }
 }

 alert( user.ref().name )
 ``